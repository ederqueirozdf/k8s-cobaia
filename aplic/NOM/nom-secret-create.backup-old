{{- define "helm-lib.randomValuePreserveIfUpgrade" -}}
  {{- if .release.IsUpgrade -}}
    {{- if hasKey .secrets "existing" -}}
      {{- $existing := get .secrets "existing" -}}
      {{- if hasKey $existing .key -}}
        {{- get $existing .key -}}
      {{- else }}
        {{- printf "%s" (include "helm-lib.generatePassword" .complexity) | b64enc -}}
      {{- end -}}
    {{- else -}}
      {{- fail "Internal error: Cannot find 'existing' in supplied 'secrets' Dictionary" -}}
    {{- end -}}
  {{- else -}}
    {{- if hasKey .inSecrets .key -}}
      {{- get .inSecrets .key -}}
    {{- else -}}
      {{- printf "%s" (include "helm-lib.generatePassword" .complexity) | b64enc -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

{{- define "helm-lib.keyWithRandomValuePreserveIfUpgrade" -}}
  {{- $pass := include "helm-lib.randomValuePreserveIfUpgrade" (dict "key" .key "complexity" .complexity "release" .release "secrets" .secrets "inSecrets" .inSecrets) | quote -}}
  {{- printf "%s: %s" .key $pass | nindent 2 -}}
{{- end -}}

apiVersion: v1
kind: Secret
metadata:
  {{- $secretName := .Values.global.initSecrets }}
  {{- $special := "-+?.,<>:;[]{}~!@#%^&*()_|$" }}
  {{- $na_special := "-+?.,<>:;[]~!@#%^&*()_|$" }}
  name: {{ $secretName }}
data:
  # This line captures the current set values from the existing K8S Secret, in case of upgrade
  {{- template "helm-lib.getSecretsDefaultsDict" ($secrets := (dict "namespace" .Release.Namespace "name" $secretName "map" .Values.secrets)) }}

  # This line captures the current values from the secrets yaml that is passed as input to helm install/upgrade
  {{- $inSecrets := .Values.secrets }}

  {{- if .Values.global.database.internal }}
  # Embedded postgresql
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "ITOM_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "APLS_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "BVD_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "IDM_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- if ne .Values.global.nom.edition "perf-bvd" }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "BTCD_DB_PASSWD_KEY" "complexity" (dict "L" 10  "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- end }}
  {{- else }}
  # External postgresql
  {{- if not .Values.global.services.sharedOpticReporting }}
  APLS_DB_PASSWD_KEY: {{ required "Must define Postgres password for AutoPass user" .Values.secrets.APLS_DB_PASSWD_KEY }}
  IDM_DB_PASSWD_KEY: {{ required "Must define Postgres password for IDM user" .Values.secrets.IDM_DB_PASSWD_KEY }}
  {{- end }}
  BVD_DB_PASSWD_KEY: {{ required "Must define Postgres password for BVD user" .Values.secrets.BVD_DB_PASSWD_KEY }}
  {{- if ne .Values.global.nom.edition "perf-bvd" }}
  BTCD_DB_PASSWD_KEY: {{ required "Must define Postgres password for transformation cache BTCD user" .Values.secrets.BTCD_DB_PASSWD_KEY }}
  {{- end }}
  {{- if .Values.global.containerizedMode }}
  NOM_DB_PASSWD_KEY: {{ required "Must define Postgres password for NOM user" .Values.secrets.NOM_DB_PASSWD_KEY }}
  {{- end }}
  {{- end }}

  # generate a random password, which is required by both IDM and AutoPass as two different keys
  {{- $vaultSigningKey := include "helm-lib.randomValuePreserveIfUpgrade" (dict "key" "VAULT_SIGNING_KEY" "complexity" (dict "L" 32) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  VAULT_SIGNING_KEY: {{ $vaultSigningKey | quote }}
  # copy of above, needed by AutoPass
  IDM_SIGNING_KEY: {{ $vaultSigningKey | quote }}

  # generate a random password for NA keystore, truststore and credential store
  # NA uses different set of special characters, since '{' character at the beginning of keystore/truststore password impacts wildfly startup
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_NA_CREDENTIAL_STORE_PASSWORD" "complexity" (dict "A" true "N" true "L" 16 "special" $na_special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_NA_KEYSTORE_PASSWORD" "complexity" (dict "A" true "N" true "L" 16 "special" $na_special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_NA_TRUSTSTORE_PASSWORD" "complexity" (dict "A" true "N" true "L" 16 "special" $na_special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

  # the following two are used by IDM for inter-service communication
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "idm_transport_admin_password" "complexity" (dict "L" 10 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "idm_integration_admin_password" "complexity" (dict "L" 10 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

  # used by single sign-on (SSO)
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "HPSSO_INIT_STRING_KEY" "complexity" (dict "L" 32 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

  # hard-coded value for COSO
  passwordFormat: {{ printf "base64" | b64enc }}

  {{- if .Values.global.coso.isSelected }}
  {{- if .Values.global.vertica.embedded }}
  # use same password for both rouser and rwuser
  {{- $verticaPass := include "helm-lib.randomValuePreserveIfUpgrade" (dict "key" "ITOMDI_DBA_PASSWORD_KEY_B64" "complexity" (dict "L" 32) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  ITOMDI_DBA_PASSWORD_KEY_B64: {{ $verticaPass }}
  ITOMDI_ROUSER_PASSWORD_KEY_B64: {{ $verticaPass }}

  {{- else }}
  ITOMDI_DBA_PASSWORD_KEY_B64: {{ required "Must define Vertica password for read/write user" .Values.secrets.ITOMDI_DBA_PASSWORD_KEY_B64 }}
  ITOMDI_ROUSER_PASSWORD_KEY_B64: {{ required "Must define Vertica password for read-only user" .Values.secrets.ITOMDI_ROUSER_PASSWORD_KEY_B64 }}
  {{- end }}


  # Minio keys
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "ITOMDI_MINIO_CLIENT_ACCESS_KEY" "complexity" (dict "L" 10 "S" false) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "ITOMDI_MINIO_CLIENT_SECRET_KEY" "complexity" (dict "L" 10 "S" false) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

  {{- end }}

  # fixed value of "nomadmin" for BVD user
  bvd_admin_login: {{ printf "nomadmin" | b64enc }}

  # the BVD admin user and NOM admin user are the same, and hence share the same password but are two different keys
  idm_nom_admin_password: {{ required "Must define password for NOM admin user" .Values.secrets.idm_nom_admin_password }}
  bvd_admin_password: {{ required "Must define password for NOM admin user" .Values.secrets.idm_nom_admin_password }}
  nom_admin_vault_key_B64: {{ required "Must define password for NOM admin user" .Values.secrets.idm_nom_admin_password }}
  idm_admin_admin_password: {{ required "Must define password for NOM admin user" .Values.secrets.idm_nom_admin_password }}

  # used by NOM Zookeeper
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_ZK_ADMIN_PASSWORD_VAULT_KEY" "complexity" (dict "L" 32 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}


  {{- if .Values.global.containerizedMode }}
  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NNM_SYS_PASSWD_KEY" "complexity" (dict "L" 32 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}
  {{- else }}
  {{- if .Values.global.nnmi.isSelected }}
  NNM_SYS_PASSWD_KEY: {{ required "Must define password for NNMi 'system' user" .Values.secrets.NNM_SYS_PASSWD_KEY }}
  {{- end }}
  {{- end }}

  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "NOM_UI_SECRET_KEY" "complexity" (dict "L" 32 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

  # perfT is (by default) always true, even when NPS is not used, so we need a different parameter to determine if Sybase password is required
  {{- if .Values.itomnomcosodataaccess }}
  {{- if .Values.itomnomcosodataaccess.sybase }}
  {{- if .Values.itomnomcosodataaccess.sybase.host }}
  SYBASE_DB_PASSWORD_KEY_B64: {{ .Values.secrets.SYBASE_DB_PASSWORD_KEY_B64 }}
  {{- end }}
  {{- end }}
  {{- end }}

  {{- if eq .Values.global.cluster.k8sProvider "aws" }}
  {{- if or (eq .Values.global.nom.edition "premium") (eq .Values.global.nom.edition "ultimate") }}
  {{- if and .Values.global.traffic .Values.global.traffic.isSelected }}
  ITOMDI_S3_ADMIN_ACCESS_KEY: {{ .Values.secrets.ITOMDI_S3_ADMIN_ACCESS_KEY }}
  ITOMDI_S3_ADMIN_SECRET_KEY: {{ .Values.secrets.ITOMDI_S3_ADMIN_SECRET_KEY }}
  {{- end }}
  {{- end }}
  {{- end }}

  {{- include "helm-lib.keyWithRandomValuePreserveIfUpgrade" (dict "key" "BACKUP_API_KEY" "complexity" (dict "L" 32 "special" $special) "release" .Release "secrets" $secrets "inSecrets" $inSecrets) }}

